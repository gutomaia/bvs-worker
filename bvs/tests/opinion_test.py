from unittest import TestCase
from mock import patch
from fakeredis import FakeStrictRedis
import httpretty
import json
import re
from faker import Factory

from bvs.alchemy import opinion
from bvs.alchemy import notify_score

import random
fake = Factory.create()

class OpinionTest(TestCase):


    def fake_alchemy_api(self, request, uri, headers):
        data = {
            "status": "OK",
            "usage": "By accessing AlchemyAPI or using information generated by AlchemyAPI, you are agreeing to be bound by the AlchemyAPI Terms of Use: http://www.alchemyapi.com/company/terms.html",
            "totalTransactions": "1",
            "language": "english",
            "docSentiment": {
                "score": str(random.random()),
                "type": "positive"
            }
        }

        for k,v in self.alchemyapi_data.iteritems():
            keys = k.split('_')
            if len(keys) == 2:
                data[keys[0]][keys[1]] = v
            else:
                data[keys[0]] = v

        return (200, headers, json.dumps(data))

    def setUp(self):
        self.alchemyapi_data = {}
        httpretty.enable()
        httpretty.register_uri(
            method=httpretty.POST,
            uri=re.compile(r'http://access.alchemyapi.com/calls/text/TextGetTargetedSentiment(\?.*)?'),
            body=self.fake_alchemy_api
        )

        # TODO: httpretty.HTTPretty.allow_net_connect = False

        self.redis = FakeStrictRedis()
        self.redis_patcher = patch('bvs.database.StrictRedis')
        self.redis_mock = self.redis_patcher.start()
        self.redis_mock.return_value = self.redis

    def tearDown(self):
        httpretty.disable()
        self.redis_patcher.stop()

    def constraint_alchemy_api(self, **kwargs):
        self.alchemyapi_data = kwargs

    def constraint_score(self, **kwargs):
        data = {
            'positive': random.randint(0, 100),
            'neutral': random.randint(0, 100),
            'negative': random.randint(0, 100),
            'error': random.randint(0, 100),
        }
        data.update(kwargs)
        for k, v in data.iteritems():
            self.redis.set(k, v)

    def fixture_tweet(self):
        tweet = dict(
            id = 4564560,
            user = 'batman',
            picture = 'http://twitter.com/batman.jpg',
            msg = "It's fantastic BvS",
            timestamp = 1231231,
        )

        return tweet

    def test_simple_alchemy_call(self):
        tweet = self.fixture_tweet()
        actual = opinion(tweet, 'any')
        # self.assertTrue(False)

    def test_positive_opinion(self):
        self.constraint_alchemy_api(docSentiment_type='positive')

        tweet = self.fixture_tweet()
        actual = opinion(tweet, 'any')

        self.assertEquals('positive', tweet['status'])

    def test_negative_opinion(self):
        self.constraint_alchemy_api(docSentiment_type='negative')

        tweet = self.fixture_tweet()
        actual = opinion(tweet, 'any')

        self.assertEquals('negative', tweet['status'])


    def test_score(self):
        self.constraint_score(positive=23)
        pubsub = self.redis.pubsub()
        pubsub.subscribe('score')

        notify_score()

        msg = pubsub.get_message()

        self.assertEquals(msg['channel'], 'score')
        # TODO test msg['data']


